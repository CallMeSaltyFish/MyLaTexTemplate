%-*- coding=utf-8 -*-
\documentclass[UTF8]{ctexart}
\usepackage{geometry}
\usepackage{cite}
\CTEXsetup[format={\Huge\bfseries}]{section}
\CTEXsetup[format={\LARGE\bfseries}]{subsection}
%\usepackage{titlesec}
\geometry{left=3.18cm,right=3.18cm,top=2.54cm,bottom=2.54cm}
\usepackage{graphicx}
\pagestyle{plain}	
% \usepackage{booktabs}
% \usepackage{subfigure}
\usepackage{setspace}
\begin{document}
\nocite{*}%show all references
\bibliographystyle{plain}
	\begin{center}
		\quad \\
		\quad \\
		\vskip 3.5cm
		\heiti \fontsize{45}{17} 实习报告
		\vskip 3.5cm
		%\heiti \fontsize{39}{17} 课程设计
	\end{center}
	\vskip 3.5cm
	\begin{quotation}
		\heiti \fontsize{36}{17}
		\doublespacing
		\par\setlength\parindent{12em}
		\quad 
		\heiti		
		
		姓\hspace{0.61cm} 名：\underline{王梓岩}
		
		学\hspace{0.61cm} 号：\underline{71Y16118}

		学\hspace{0.61cm} 院：\underline{软件学院}
		
		实习单位：\underline{National Instruments}
		
		\vskip 2cm
		\centering
	\end{quotation}
	
\newpage
\songti \fontsize{13}{13}
\large

\section{企业背景及企业文化}
\subsection{实习单位简介}
本人实习单位为美国国家仪器公司中国上海分公司。国家仪器股份有限公司（National Instruments，简称NI或恩艾仪器）是一家美国公司，从事与测试、控
制、设计领域相关的，包括虚拟仪器和电子测试设备等工程软件的开发。著名产品有图形开发环境LabVIEW、C语言虚拟仪器应用系统LabWindows/CVI、集成电
路分析程序NI Multisim等等；硬件产品包括VXI总线、PXI总线、VME总线的框架与模块，IEEE-488接口以及内部整合电路和其他自动化技术的标准。作为一家
自2000年连续11年入选财富杂志百大最佳工作环境名单的公司，国家仪器在全球范围内拥有五千余名员工并在41个国家经营。NI拥有庞大的用户群体——仅在
2004年度，全球就有超过25，000家公司从NI购买了产品。用户的智慧结合NI先进、优质的产品，造就了无数成功的测试测量方案。借助商业化的计算机平台，
用户仅以传统测试测量系统一半乃至十分之一的成本，便可获得与之相同或更出色的功能。现在，NI中国分公司委托国家级计量单位上海计量院为有需求的用
户提供有偿的专业校验与校准服务，颁发校验证书，确保产品的长期测量精度。
\subsection{工作岗位简介}
本人的岗位为Research \& Development(研究与开发)部的实习开发工程师，负责部门蓝牙、FPGA、Azure Pipeline等项目的开发与日常维护，以下会详细说明
实习经历及项目。R\&D部门最重要的工作是为其他硬件设施提供软件支持或驱动，也负责研究一些新兴技术如低功耗蓝牙、ATS自动化测试等。R\&D部门在很大
程度上受物联网和无线标准爆炸的推动，无线已成为连接设备不可或缺的一部分。NI创建了快速且经济高效的无线测试解决方案，设计出了创新和高质量的产
品。NI解决方案简化了并行测试，缩短了测试时间，并降低了测试成本。NI测试解决方案从一致性到大批量生产，从5G到802.11ax，再到近场通信（NFC）和无
线充电。NI矢量信号收发器（VST）设计用于对各种无线设备进行快速而准确的测试，包括WLAN接入点，蜂窝手机和信息娱乐系统。R\&D部门日常使用的开发语
言有c、python、yml、LabVIEW、powershell等，使用git进行版本控制，perforce进行云端数据的存储。

\section{实习环节中遇到的问题及困难}
第一次来公司时，首先将接受为期半个月的培训。在仅六个月的实习中，半个月的培训显然占据了很长时间。在一开始的培训期间，主要学习了公司的发展理念、路线制定、客户关系和发展蓝图等，并对公司发展历程有所了解。在培训的后期，主要任务是不断深化我们的专业技能，因为在学校学习到的大多数专业知识实际上并不适用于工作，当然，不是说完全用不上，而是不能一味地照搬照抄，毕竟奠定坚实的基础是非常重要的。在实际的操作中，我在培训时使用的开发软件与之前学习阶段所使用的软件有很大不同，尽管它确实更加强大，但起初我并不习惯，好在经过几天的适应，我逐渐习惯起来。从培训中受益匪浅，学到了很多很有价值的知识和经验，可以在以后的工作中使用。
\par
按照公司文档，将工作的电脑配置 python 2.7，python 3.6，LabVIEW，C\#，和GIT的运行环境，并且按照文档的介绍熟悉了GIT的 add，push，pull，
commit，remove等操作。特别地，由于今后的开发中会同时用到 python 的 2.x 和 3.x 版本，且python 2和python 3互不兼容，按照参考文档，使用 
anaconda管理python环境，同时建立两个虚拟环境，分别为2.x 版本和3.x版本，这样以后可以在终端中输入“activate 环境名”来达到使用不同版本 python
的目的。
\par
按照公司的规定，开发文档也应由git管理，而常用的MS Word文档均为二进制文件，故不适合用git管理，因此，公司文档均由markdown书写。熟悉了md的基本
语法、会编写一个完整的markdown文档，markdown的插入公式的格式完全来源于LaTex，因此学习起来不算困难。熟悉了云端存储办公软件perforce的基本用法
及命令行操作。
\par
熟悉命令行操作在实际的开发中可以大大提高开发效率，在Windows操作系统上，powershell的实用性非常大，熟悉并掌握powershell的常用操作十分必要，且
git的若干操作通过命令行执行效率更高。在powershell中，所有cmd指令都是可用的，比如dir，cd，tree，echo等。powershell也吸收了unix平台的一些操作
，比如ls，rm等。powershell最重要的就是指令（cmdlet），可以视为函数或者方法。首先cmd的指令和部分类unix指令可以使用，比如：echo（打印），cd
（进入目录），dir/ls（打印目录内容），cp（复制文件），mv（移动文件），mkdir（创建目录）等。powershell 内置许多非常强大的指令，比如 Get-Item
（获取文件对象）， Test-Path（检查路径是否存在）， Get-Date（获取当前时间）等，具体可查阅微软官方手册。powershell 一个非常重要的功能就是管
道运算符（|），即在一组命令中，输出的命令结果成为下一个命令的输入参数。管道的概念与真实生活中的生产线比较相似：在不同的生产环节进行连续的再
加工，我们可以发现管道运算符的写法逻辑非常清晰，易于理解。
\par
入门阶段主要是熟悉各种开发语言、开发工具的操作和用途，相当于是起步阶段，虽然有的工具还不是非常熟悉，但在今后的开发中可以继续积累经验，达到熟
能生巧的地步。版本控制这一思想在本科阶段的课程中体现的不是很重要，但在实际开发的过程中却是非常重要的，今后的开发，即便是个人的敏捷开发，也尽
量使用版本管理工具来进行控制，对于形成软件工程的思想，是大有裨益的。
\par
对于实习中在项目上遇到的困难及解决方案，在下一部分会详细地一一说明。
\section{具体解决方案}
\subsection{FPGA编译器语义分析}
\subsubsection{总览}
FPGA编译器语义分析流程大致分为以下几个部分：
\par
1. 从源模型构建初始DFIR。
\par
2. 根据编译上下文确定用户未设置或动态设置的语义属性(例如，可编译源模型通常不指定所有数据类型和隧道方向)。
\par
3. 检测非法的源构造，例如未接线的端子，不兼容的类型，不良的循环等。
\par
4. 将由编译器确定的属性和/或消息反映到源模型。
\par
5. 产生准备用于后续编译阶段使用的DFIR。触发SA以响应各种编译器和源模型事件。例如，源模型更改会更改模型的任何语义含义，或者更改依赖项在语义上
影响依赖者的任何依赖项。
\subsubsection{更改可编译源模型}
1. 加载模型：加载模型时，CompilerService会附加到模型上，然后从SA开始。这仅仅是为了确保正确设置此源模型中的所有语义属性。许多计算出的语义属性
只是没有保存在源模型中，因此需要在每次加载时进行设置。
\par
2. 编辑模型：具有语义效果的任何编辑都将要求进行编译。CompilerService正在监听ITransactionManager.TransactionStateChanged事件。如果事务中有任
何事务项导致源文件在语义上被认为是脏的，SA将启动。与MocPlugin关联的对象将根据相应的计算模型来确定哪些交易是语义更改。如果用户
操作(例如撤消、重做)引起了语义上的变化，也将对其进行检查，并根据检查结果触发SA。
\par
3. 在编辑器中打开模型：在编辑器中打开文档或创建新文档时，UI线程将附加到Envoy，这将增加的用户优先级 Envoy。编译器服务会关注Envoy通孔的用户优先
级变化，IUserPriorityEnvoyService并且在从未对源模型副本进行语义分析时会触发(高优先级)SA。
\subsubsection{更改不可编译源模型}
1. WaitForSemanticAnalysisAsync：CompilerService公开的API，用于请求和等待SA结果，如果没有运行SA或正在为请求的SA运行BuildSpec，那么将启动一个
新的WaitForSemanticAnalysisAsync。
\par
2. GetTargetDfirAsync：IAnyMocCompiler公开的API以获取目标级别的DFIR，它将触发一次SA，以确保在有效的SA之后生成目标级别的DFIR。
\par
3. TargetCompiler.CompileAsync：TargetCompiler运行后端编译的API将调用GetTargetDfirAsync以获取目标级别的DFIR进行编译，它也可以调度SA。
\subsubsection{SA的执行流程}
创建一个SemanticAnalysisActivity对象，SemanticAnalysisActivity为每个SA申请内存并在后台线程上运行。一旦开始运行，活动将查询MocPlugin来生成源
DFIR，它将可编译的源模型转换为源DFIR。
\par
\subsubsection{Moc插件}
Moc插件定义了一个语义分析所依赖的算法或数学模型，一个完整的Moc插件需要定义以下几个部分：
\par
1. MocReflector：MocReflector附加到它生成的源DFIR。MocReflector可以容纳特定于计算模型的反射变换。
\par
2. MocTransformManager：MocTransformManager提供了DFIR转换的时间表，构成了语义分析完成的其余工作。这些变换可以包括SemanticAnalysisTransform
针对计算模型的通用变换以及其他特定于模型的变换。
\par
3. SemanticAnalysisTransform：此转换执行标准的数据流语义分析，即在DFIR 图上的完整类型传播。
\par
4. InternalTypePropagationVisitor：可以将其配置为访问DFIR上的所有或部分节点子集。转换期间将调用任何插件节点以进行其类型传播。
\par
5. ReflectionTransform：此转换负责将任何编译结果反映到源模型。如果每个Moc插件在其DFIR图中具有任何非标准的语义信息或插件DFIR点，则都需要考虑
使用自己的类型/语义信息反射转换。该模块由Pipeline自动生成，不应手动修改其代码。
\par

\subsection{自动化测试系统}
NI的自动化测试系统（Automated Testing System，简称ATS）是为了对FPGA、驱动器等产品进行自动化测试的平台，ATS建立在Azure Pipeline的架构上。对
测试平台的主要工作为修改 ATS 系统以跳过 FPGA 的编译。
\subsubsection{ATS原有设计方案}
(对于每一个测试用例)加载 YAML 配置文件，YAML(YML)是一种类似于 XML或 JSON 的结构化语言，也是靠映射形成的一个多级目录，一个主键可以引导一个值
或一个字典，可视为一个分级的散列。此时所有测试用例进入初始化(initialized)状态。
\par
进行预处理(manipulate)操作，状态置为预处理(manipulated)状态。
\par
进行编译(compile)操作。当测试用例还在编译的时候，状态为正在编译 (compiling)，一旦结束状态就变为已编译(compiled)。
\par
部署(deploy)并运行(run)测试用例，状态置为部署并运行(deploy \& run)。
\par
输出测试结果，结束。
\subsubsection{ATS改进方案}
通过白盒检查代码易于发现，在编译的过程中，每有一个测试用例，就专门申请一个线程，负责该测试用例的编译工作。一旦编译完成，该线程就将状态更新
为“已编译”。与此同时，主线程不停地轮询所有测试用例的状态，当所有测试用例的状态均为已编译时，即可进行接下来的步骤。
\par
基于以上信息，对 ATS 作出的改进为:对于每一个测试用例，在“申请线程”操作之前，先检查一个布尔值，这里命名为 skip\_compile。如果布尔值为真，直接
将该测试用例的状态改为“已编译”，之后直接轮到下一个测试用例;否则，按原有的代码逻辑进行操作。这样一来，对于一个不需要编译的测试用例来说，不会
执行申请线程、开始编译等所有的编译相关操作，直接被视为已编译。将该测试用例的状态改为“已编译”这一操作十分重要，不仅可以被主线程视为已经编译，
同时在下一个阶段执行之前，所有的测试用例的状态会被检查一遍，如果状态是“已编译”之前的状态，代码会抛出异常，这样做可使代码正常运行。
\par
最后一个待解决的问题就是布尔值 skip\_compile 如何得到。前面已经指出，ATS 的第一步就是读取配置文件，这就要求测试人员在每次测试之前显式地添加
表达式“skip\_compile:True”，才能使ATS系统正常运行。

\subsection{Azure Pipeline}
\subsubsection{Azure Pipeline概述}
Azure Pipelines是一种云服务，可用于自动构建和测试代码项目并将其提供给其他用户。它几乎适用于任何语言或项目类型。Azure Pipelines将持续集成（CI）和持续交付（CD）相结合，以持续不断地测试和构建代码并将其交付给任何目标。
\par
构建CI和CD管道有助于确保始终如一地提供给用户的一致且高质量的代码。而且，Azure Pipelines提供了一种快速，轻松和安全的方式来自动构建项目并将其提供给用户。Azure Pipelines，支持以下特性：适用于任何语言或平台、同时部署到不同类型的目标、与Azure部署集成、在Windows，Linux或Mac机器上构建、与GitHub集成、与开源项目一起使用等等。
\subsubsection{Azure Pipeline工作机制}
整个管道的入口是 build-system-test.yml。在 build-system-test.yml 中，将触发 build-system-test-template.yml。 build-system-test-template.yml有3个阶段，即：prtest，citest和checkbuild。 prtest和citest可以同时执行，因为它们都没有依赖。当输入彼此不同时，prtest和citest将分别触发build-system-test-build-components.yml。最后，仅当prtest和citest都已完成时，才运行checkbuild。 checkbuild是整个过程的最后一步。
\par
build-system-test-build-components.yml中有几个工作。 它们可以表示为 init-build，test-azdp-comp-a ，test-azdp-comp-b ，test-azdp-compc ，test-azdp-comp-d 和 finalize-build 。 它们之间的依赖关系如下图所示。init-build 将触发 init-build.yml 。在init-build.yml中，有一项工作包含6个步骤，分别是签出，初始化构建工具，分发，获取，重建和发布到管道工件。分步初始化构建工具将调用initialize-build-tools.yml。文件initialize-build-tools.yml 不会触发任何其他yaml文件。对于test-azdp-comp-a，test-azdp-comp-b ，test-azdp-compc 和 test-azdp-comp-d，它们各自将分别调用pipeline-nibuild-build-component.yml。在 finalize-build.yml 中定义了 finalize-build ，它将调用 initialize-build-tools.yml。
\par
build-components.yml仅包含一项包含多个步骤的作业。由于它们来自不同的调用者，甚至调用者有可能属于prtest或citest，因此执行过程可能会有所不同，可以跳过某些步骤。
\subsection{关于Android开发的学习}
\subsubsection{Android 系统特性与平台架构}
系统特性: 应用程序框架支持组件的重用与替换(app 发布时遵守了框架的约定,其他 app 也可以使用 该模块)。Dalvik 虚拟机:专门为移动设备优化——集成的浏览器:开源的 WebKit 引擎。 SQLite 结构化的数据存储。 优化的图形库,多媒体支持,GSM 电话技术,蓝牙等。 采用软件叠层方式构建。 
\par
如何理解 Android 架构: Application(应用程序层) 我们一般说的应用层的开发就是在这个层次上进行的,当然包括了 系统内置的一组应用程序,使用的是 Java 语言。 
\par
Application Framework(应用程序框架层) 无论系统内置或者我们自己编写的 App,都需要使 用到这层,比如我们想弄来电黑名单,自动挂断电话,我们就需要用到电话管理 (TelephonyManager) 通过该层我们就可以很轻松的实现挂断操作,而不需要关心底层实现。 
\par
Libraries(库) + Android Runtime(Android 运行时) Android 给我们提供了一组 C/C++库,为平台 的不同组件所使用,比如媒体框架;而 Android Runtime 则由 Android 核心库集 + Dalvik 虚 拟机构成,Dalvik 虚拟机是针对移动设备的虚拟机,它的特点:不需要很快的 CPU 计算速度 和大量的内存空间;而每个 App 都单独地运行在单独的 Dalvik 虚拟机内。
\subsubsection{Android Activity}
活动代表了一个具有用户界面的单一屏幕,如 Java 的窗口或者帧。Android 的活动是 ContextThemeWrapper 类的子类。类似于 C,C++ 或者 Java 语言编程,程序从 main() 函数 开始,Android 系统初始化它的程序是通过活动中的 onCreate() 回调的调用开始的。存在有 一序列的回调方法来启动一个活动,同时有一序列的方法来关闭活动。 Activity 类定义了下面的回调。在继承 Activity 类的时候可以不用实现所有的回调方法。但了 解其中的每一个非常的重要: onCreate():这是第一个回调,在活动第一次创建时调用;onStart():这个回调在活动为用户可见时被调用;onResume():这个回调在应用程序与用户开始可交互的时候调用;onPause():被暂停的活动无法接受用户输入,不能执行任何代码。当前活动将要被暂停,上 一个活动将要被恢复时调用;onStop():当活动不在可见时调用 ;onDestroy():当活动被系统销毁之前调用;onRestart():当活动被停止以后重新打开时调用
\subsubsection{Android Service}
Service(服务)是一种可在后台执行长时间运行操作而不提供界面的应用组件。服务可由其
他应用组件启动,而且即使用户切换到其他应用,服务仍将在后台继续运行。此外,组件可
通过绑定到服务与之进行交互,甚至是执行进程间通信 (IPC)。例如,服务可在后台处理网
络事务、播放音乐,执行文件 I/O 或与内容提供程序进行交互。
\par
服务分为三种类型:前台、后台、绑定
\par
前台服务:执行一些用户能注意到的操作。例如,音频应用会使用前台服务来播放音频曲目。
前台服务必须显示通知。即使用户停止与应用的交互,前台服务仍会继续运行。
\par
后台服务:执行用户不会直接注意到的操作。例如,如果应用使用某个服务来压缩其存储空
间,则此服务通常是后台服务。
\par
绑定服务:当应用组件通过调用 bindService() 绑定到服务时,服务即处于绑定状态。绑定服
务会提供客户端-服务器接口,以便组件与服务进行交互、发送请求、接收结果,甚至是利用
进程间通信 (IPC) 跨进程执行这些操作。仅当与另一个应用组件绑定时,绑定服务才会运行。
\par
多个组件可同时绑定到该服务,但全部取消绑定后,该服务即会被销毁。服务可同时以这两
种方式运行,换言之,它既可以是启动服务(以无限期运行),亦支持绑定。唯一的问题在于
是否实现一组回调方法:onStartCommand()(让组件启动服务)和 onBind()(实现服务绑定)。
无论服务是处于启动状态还是绑定状态(或同时处于这两种状态),任何应用组件均可像使用
Activity 那样,通过调用 Intent 来使用服务(即使此服务来自另一应用)。不过,也可以通
过清单文件将服务声明为私有服务,并阻止其他应用访问该服务。
如要创建服务,必须创建 Service 的子类(或使用它的一个现有子类)。在实现中,必须重写
一些回调方法,从而处理服务生命周期的某些关键操作,并提供一种机制将组件绑定到服务。
以下是应重写的最重要的回调方法:
\par
onStartCommand()：当另一个组件(如 Activity)请求启动服务时,系统会通过调用 startService() 来调用此方法。
执行此方法时,服务即会启动并可在后台无限期运行。如果实现此方法,则在服务工作完成
后,需负责通过调用 stopSelf() 或 stopService() 来停止服务。
\par
onBind()：
当另一个组件想要与服务绑定(例如执行 RPC)时,系统会通过调用 bindService() 来调用
此方法。在此方法的实现中,必须通过返回 IBinder 提供一个接口,以供客户端用来与服务
进行通信。
\par
onCreate()：
首次创建服务时,系统会(在调用 onStartCommand() 或 onBind() 之前)调用此方法来执行
一次性设置程序。如果服务已在运行,则不会调用此方法。
\par
onDestroy()：
当不再使用服务且准备将其销毁时,系统会调用此方法。服务应通过实现此方法来清理任何
资源,如线程、注册的侦听器、接收器等。这是服务接收的最后一个调用。
如果组件通过调用 startService() 启动服务(这会引起对 onStartCommand() 的调用),则服
务会一直运行,直到其使用 stopSelf() 自行停止运行,或由其他组件通过调用 stopService()
将其停止为止。如果组件通过调用 bindService() 来创建服务,且未调用 onStartCommand(),
则服务只会在该组件与其绑定时运行。当该服务与其所有组件取消绑定后,系统便会将其销
毁。只有在内存过低且必须回收系统资源以供拥有用户焦点的 Activity 使用时,Android 系
统才会停止服务。如果将服务绑定到拥有用户焦点的 Activity,则它其不太可能会终止;如
果将服务声明为在前台运行,则其几乎永远不会终止。如果服务已启动并长时间运行,则系
统逐渐降低其在后台任务列表中的位置,而服务被终止的概率也会大幅提升—如果服务是启
动服务,则必须将其设计为能够妥善处理系统执行的重启。
\subsubsection{Android Content}
基本上每一个应用程序都会有一个自己的 Context,并让它继承自系统的 Context 类,然
后在自己的 Context 类中去封装一些通用的操作。其实这并不是 Google 所推荐的一种做法,
因为这样我们只是把 Context 当成了一个通用工具类来使用的,而实际上使用一个简单的单
例类也可以实现同样的功能。但是根据我的观察,有太多的项目都是这样使用 Context 的。
当然这种做法也并没有什么副作用,只是说明还是有不少人对于 Context 理解的还有些欠缺。
那么这里我们先来对 Context 的设计进行分析。
\par
一个 Activity 就是一个 Context,一个 Service 也是一个 Context。Android 程序员把“场
景”抽象为 Context 类,他们认为用户和操作系统的每一次交互都是一个场景,比如打电话、
发短信,这些都是一个有界面的场景,还有一些没有界面的场景,比如后台运行的服务
(Service)。一个应用程序可以认为是一个工作环境,用户在这个环境中会切换到不同的场景,
这就像一个前台秘书,她可能需要接待客人,可能要打印文件,还可能要接听客户电话,而
这些就称之为不同的场景,前台秘书可以称之为一个应用程序。
\par
上面的概念中采用了通俗的理解方式,将 Context 理解为“上下文”或者“场景”,如果
仍然觉得很抽象,不好理解。在这里我给出一个可能不是很恰当的比喻,希望有助于理解:
一个 Android 应用程序,可以理解为一部电影或者一部电视剧, Activity, Service, Broadcast
Receiver, Content Provider 这四大组件就好比是这部戏里的四个主角,他们是由剧组(系统)
一开始就定好了的,整部戏就是由这四位主演领衔担纲的,所以这四位主角并不是大街上随
随便便拉个人(new 一个对象)都能演的。有了演员当然也得有摄像机拍摄啊,他们必须通
过镜头(Context)才能将戏传递给观众,这也就正对应说四大组件(四位主角)必须工作在
Context 环境下(摄像机镜头)。那 Button,TextView,LinearLayout 这些控件呢,就好比是
这部戏里的配角或者说群众演员,他们显然没有这么重用,随便一个路人甲路人乙都能演(可
以 new 一个对象),但是他们也必须要面对镜头(工作在 Context 环境下),所以 Button
mButton=new Button(Context)是可以的。虽然不很恰当,但还是很容易理解的,希望有帮
助。
\par
通常我们想要获取 Context 对象,主要有以下四种方法
\par
1:View.getContext,返回当前 View 对象的 Context 对象,通常是当前正在展示的 Activity
对象。\par
2:Activity.getApplicationContext,获取当前 Activity 所在的(应用)进程的 Context 对象,通
常我们使用 Context 对象时,要优先考虑这个全局的进程 Context。\par
3 :ContextWrapper.getBaseContext(): 用来获取一个 ContextWrapper 进行装饰之前的
Context,可以使用这个方法,这个方法在实际开发中使用并不多,也不建议使用。\par
4:Activity.this 返回当前的 Activity 实例,如果是 UI 控件需要使用 Activity 作为 Context
对象,但是默认的 Toast 实际上使用 ApplicationContext 也可以。\par
上面说到获取当前 Application 对象用 getApplicationContext,联想到 getApplication(),这
两个方法有什么区别?实际上没有区别,通过实验,打印得出两者的内存地址都是相同的,
看来它们是同一个对象。其实这个结果也很好理解,因为前面已经说过了,Application 本身
就是一个 Context,所以这里获取 getApplicationContext()得到的结果就是 Application 本身的
实例。那么问题来了,既然这两个方法得到的结果都是相同的,那么 Android 为什么要提供
两个功能重复的方法呢?实际上这两个方法在作用域上有比较大的区别。getApplication()方
法的语义性非常强,一看就知道是用来获取 Application 实例的,但是这个方法只有在 Activity
和 Service 中才能调用的到。那么也许在绝大多数情况下我们都是在 Activity 或者 Service 中
使用 Application 的,但是如果在一些其它的场景,比如 BroadcastReceiver 中也想获得
Application 的实例,这时就可以借助 getApplicationContext()方法了。
\par
总之 Context 在 Android 系统中的地位很重要,它几乎无所不能,但它也不是你想用就能
随便用的,谨防使用不当引起的内存问题。
\subsection{关于nRF5蓝牙开发板的学习}
\subsubsection{影响蓝牙 RSSI 的主要因素}
距离:显然地,距离越大,接收到的蓝牙 RSSI 强度就越小。\par
室内环境:墙壁、家具以及其他室内物品会导致信号的衰减、吸收和反射,以上这些和直线
传播相比会大大降低蓝牙传播的信号强度。\par
阻挡:当发射器和接收器之间有东西阻挡时,信号强度会被减弱。\par
信号发生器的天线功率:天线功率越高,发出信号的 RSSI 就越高,同时电池寿命也会损耗
的更快。\par
信号接收器的灵敏度:灵敏度越高,接收信号的 RSSI 就越高。\par
信号发生器、接收器的朝向:显然地,只有当两者正对着的时候,RSSI 才能达到最大值。\par
空气密度:空气密度越高,信号就会衰减的越快。
\subsubsection{影响蓝牙 RSSI 的主要因素}
RSSI 的测量方法采用基于区域的方法,首先必须进行系统校准以定义即时,近和远范围
的值。例如,即时范围可能在 1 米以下,近距离可能在 1 至 6 米之间,而远距离可能超过 6
米。
\par
在这种情况下,用户可以站在信标正好一米处,面向信标,并在手机上记录 RSSI 读数。
这些读数的平均值将定义立即范围的边界。同样,六米处的 RSSI 读数的平均值与一米处的
RSSI 读数的平均值将定义近距离范围,同样也定义远距离范围。校准过程完成后,将记录的
值存储在数据库中,然后将在运行时查询该值,以使用测得的 RSSI 值为给定信标建立区域。
由于 RSSI 在各个范围的边缘可能会略有变化,因此这种实现方式会导致渐进的边界而不是
尖锐的边界。例如,近距离范围的上限可能在 5 至 7 米之间,而不是 6 米。在大多数情况下,
这种变化通常是可以接受的。
\par
RSSI 值取决于发射功率,因此具有不同发射功率配置的不同信标将导致相同距离处的不
同 RSSI 值。
\par
因此,在进行校准之前,确保信标具有相同的发射功率。 另一个重要的一点是 RSSI 的
读数因手机而异,这是考虑到基于 Android 的不同手机的关键问题。 补偿这种变化的一种方
法是使用高质量(高灵敏度)电话,并在离所需范围限制稍远的位置进行校准。 例如,当校
准即时范围至一米时,请站在 1.2-1.5 米处进行校准。 高灵敏度电话在 1.2-1.5 米处拾取的信
号电平可以与低灵敏度电话在 1 米处拾取的信号电平相同。 同样,可以将近距离校准为 7
米而不是 6 米。 这样,我们可以容纳各种手机型号。
\section{个人心得及体会}
本次实习使我收获很多，无论是技术、认识还是沟通等方面，都使我有了一个很大的进步，在技术上应当不断深入、不断学习，在交流上应当虚心请教，及时沟通，同时也要平衡生活和工作，合理安排好时间，合理安排今后的规划，不断学习，继续进步。
\par
本科生参与实习，可以透过理论联系实际，巩固所学的知识，提高处理实际问题的潜力，为顺利毕业进行做好充分的准备，并为自身能顺利与社会环境接轨做
准备。透过实习，进一步理解和领会所学的基本理论，了解计算机技术和信息管理技术的发展及应用，较为系统地掌握计算机应用技能和信息管理技能，把所
学知识与解决实际问题相联系，能够利用计算机处理工作中的各种信息，培养发现问题、分析问题和解决问题的潜力，从而提高从事实际工作的潜力。
\par
生产实习是一个极为重要的实践性教学环节。透过实习，使学生在社会实践中接触与本专业相关的实际工作，增强感性认识，培养和锻炼学生综合运用所学的
基础理论、基本技能和专业知识，去独立分析和解决实际问题的潜力，把理论和实践结合起来，提高实践动手潜力，为学生毕业后走上工作岗位打下必须的基
础；同时能够检验教学效果，为进一步提高教育教学质量，培养合格人才积累经验。计算机是一门对实践要求较高的学科，透过专业实习，使学生能熟悉有关
计算机专业的各个领域，使学生毕业后能胜任与本专业相关的工作。
\par
大学本科期间，主要学习的是理论基础知识，辅以实践环节，由于缺乏对当今社会市场的了解，从而无法有效地将所学知识运用到实际的生产生活中去。此时，
毕业实习的好处就凸显出来，通过亲身参与毕业实习，学生有机会接触第一线的计算机行业的工作内容及流程，有条件进行进一步的深造，从而给高校学生一
个了解社会，增加经验，熟悉工作单位的机会。锻炼自身的动手潜力，将学习的理论知识运用于实践当中，反过来还能检验书本上理论的正确性，有利于融会
贯通。同时，也能开拓视野，完善自身的知识结构，到达锻炼潜力的目的。一切都是为了让实践者对本专业知识构成一个客观，理性的认识，从而不与社会现
实相脱节。此外透过理论联系实际，巩固所学的知识，提高处理实际问题的潜力，了解设计专题的主要资料，为毕业设计的顺利进行做好充分的准备，并为自
己能顺利与社会环境接轨做准备。
\par
通过实习使我对计算机有了更具体认识，通过对计算机的具体操作和亲自实践巩固了课本上学的知识，在这个基础上把所学的计算机应用专业理论知识与实践密切结合起来，培养自己实际工作能力与分析能力，达到学以致用的目的。理论与实际的结合，学校与社会的勾通，进一步提高了自己的思想觉悟，业务水平;尤其是观察分析和解决问题的实际工作能力，实习的一个重要功能，在于运用教学成果，检验教学成果。运用教学成果，就是把课堂上学到的系统化的理论知识、尝试性地应用与实际的工作中。
\par
理论是灰色的，生活之树常青，只有将理论付诸于实践才能实现理论自身的价值，也只有将理论付诸于实践才能使理论得以检验。同样，一个人的价值也是通过实践活动来实现的，也只有通过实践才能锻炼人的品质，彰现人的意志。从学校走向社会，首要面临的问题便是角色转换的问题。从一个学生转化为一个单位人，在思想的层面上，必须认识到二者的社会角色之间存在着较大的差异。学生时代只是单纯的学习知识，而社会实践则意味着继续学习，并将知识应用于实践，学生时代可以自己选择交往的对象，而社会人则更多地被他人所选择。诸此种种的差异。不胜枚举。但仅仅在思想的层面上认识到这一点还是不够的，而是必须在实际的工作和生活中潜心体会，并自觉的进行这种角色的转换。
\par
实习，是开端也是结束。实习的同时也让我了解到了自己的不足,在今后的工作和生活中，我会继续努力,完善自我。更加努力的奋斗下去。
%\bibliography{report}
\end{document}